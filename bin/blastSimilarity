#!/usr/bin/perl

use BlastAnal;
use Utils;
use strict;
use Getopt::Long;
use File::Basename;

open(LOG,">blastSimilarity.log");

my $debug = 0;

$| = 1;

my ($regex,$pValCutoff,$lengthCutoff,$percentCutoff,$outputType,$program,$rpsblast,
    $database,$seqFile,$blast_version,$startNumber,$stopNumber,$dataFile,$remMaskedRes,
    $saveAllBlastFiles,$blastFileDir,$saveGoodBlastFiles,$doNotParse,$fileExtension,
    $blastParamsFile, $doNotExitOnBlastFailure, $blastVendor, $printSimSeqsFile,$blastBinDir, $validOutput);

&GetOptions("regex=s" => \$regex, 
            "pValCutoff=f" => \$pValCutoff, 
            "lengthCutoff=i"=> \$lengthCutoff,
            "percentCutoff=i" => \$percentCutoff,
            "outputType=s" => \$outputType,
            "blastProgram=s" => \$program,
            "blastVendor=s" => \$blastVendor,
            "database=s" => \$database,
            "seqFile=s" => \$seqFile,
            "dataFile=s" => \$dataFile,
            "adjustMatchLength!" => \$remMaskedRes,
            "blastFileDir=s" => \$blastFileDir,
            "fileExtension=s" => \$fileExtension,
            "blastParamsFile=s" => \$blastParamsFile,
            "saveAllBlastFiles=s" => \$saveAllBlastFiles,
            "saveGoodBlastFiles=s" => \$saveGoodBlastFiles,
            "doNotParse=s" => \$doNotParse,
            "doNotExitOnBlastFailure=s" => \$doNotExitOnBlastFailure,
	    "blastBinDir=s" => \$blastBinDir,
	    "printSimSeqsFile=s" => \$printSimSeqsFile
            );
die "Usage: blastSimilarity --regex=<regular expression following ^\> of defline...ie '(\S+)'> --pValCutoff=<float> --lengthCutoff=<int> --percentCutoff=<int> --outputType=(summary|span|both) --blastBinDir=<directory containing blast binaries (if 'default' then must be in \$PATH)> --blastProgram=<blastprogram> --database=<blast database> --seqFile=<sequenceFile>  --trackingFile=<filename to track progress> --blastParams 'extra blast parameters' --adjustMatchLength! --saveAllBlastFiles! --blastFileDir <directory on server to put the blast files> --saveGoodBlastFiles! --fileExtension [.database_blastProgram] --doNotParse! --doNotExitOnBlastFailure! --printSimSeqsFile!\n" unless ( $program && $database && $seqFile && $blastParamsFile);

###set the defaullts...
$pValCutoff = $pValCutoff ? $pValCutoff : 1e-5;
$lengthCutoff = $lengthCutoff ? $lengthCutoff : 10;
$percentCutoff = $percentCutoff ? $percentCutoff : 20;  ##low for blastp
$outputType = $outputType ? $outputType : "both";
$blast_version = $blast_version ? $blast_version : "blast2";
$dataFile = $dataFile ? $dataFile : "blastSimilarity.out";
$regex = $regex ? $regex : '(\S+)';

my $blastParams = &parseBlastParams($blastParamsFile);

if($doNotParse eq "true"){
  $saveAllBlastFiles = "true";
}
if($saveAllBlastFiles eq "true" || $saveGoodBlastFiles eq "true"){
  if(!$fileExtension){
    my $db = basename($database);
    my $pg = basename($program);
    $fileExtension = "$db\_$pg";
  }
}

open(OUT, ">$dataFile") or &error("cannot open output file $dataFile for writing");
select OUT; $| = 1;
select STDOUT;

print LOG "processing $seqFile\n";
open(F, "$seqFile") || &error("couldn't open seqfile $seqFile");
my $tempfile = "seqTmp";
my $tmpid = "";
my $seq;
my $cmd;

if($program =~ /rpsblast/){
  $cmd = "$program -db $database -query $seqFile $blastParams";
}elsif($blastVendor eq 'ncbi'){
  my $pgm = basename($program);
  $cmd = ($blastBinDir eq 'default' ? "" : "$blastBinDir/") . "$pgm -db $database -query $seqFile $blastParams";
}else{
  $cmd= ($blastBinDir eq 'default' ? "" : "$blastBinDir/") . "$program $database $tempfile $blastParams 2> blast.stderr";
}
print LOG "$cmd\n\n";
print LOG "Parser parameters and fields:\n";
print LOG "Cutoff parameters:\n\tP value: $pValCutoff\n\tLength: $lengthCutoff\n\tPercent Identity: $percentCutoff\n\n";
print LOG "# Sum: subject_Identifier:score:pvalue:minSubjectStart:maxSubjectEnd:minQueryStart:maxQueryEnd:numberOfMatches:totalMatchLength:numberIdentical:numberPositive:isReversed:readingFrame:non-redundant query match length:non-redundant subject match length:percent of shortest sequence matched\n";
print LOG "#   HSP: subject_Identifier:numberIdentical:numberPositive:matchLength:score:PValue:subjectStart:subjectEnd:queryStart:queryEnd:isReversed:readingFrame\n\n";

while(<F>){
    if(/^\>(\S+)/){
    print LOG "DING1\n";	
    $tmpid = $1;
    }
}
processEntry($cmd, $tmpid, $program);

close F;
close OUT;
print LOG "DING2\n";
close LOG;

######################### subroutines ###########################

sub parseBlastParams {
    my ($blastParamsFile) = @_;

    open(C, "$blastParamsFile") or &error("cannot open blastParams file $blastParamsFile");
    while(<C>){
	next if /^\s*#/;
	chomp;
	$blastParams .= "$_ ";
    }
    close(C);
    print LOG "DING3\n";
    return $blastParams;
}

sub processEntry {
  my($cmd, $accession, $program) = @_;

  print STDERR "processing $accession\n";
  my $validOutput;
  my $noHits;
  my $retry = 2;
  my $try = 1;
  do {
    print LOG "DINGDO/n";  
    system("$cmd > out.txt");
    ($validOutput, $noHits) =
	&checkOutput($accession);
  } while (!$validOutput && ($try++ < $retry));

  if (!$validOutput) {
      if($doNotExitOnBlastFailure eq "true"){
      print OUT "\>$accession (ERROR: BLAST failed ($try times).";
      return; 
    } else {
	system("cat out.txt > blast.out");
	print LOG "Failed ($try times) running '$cmd'";
  }
  }
  if ($noHits==1) {
      print OUT "\>$accession (0 subjects)\n" unless ($printSimSeqsFile eq "true");
  } else {
	&analyzeBlast($accession);
	print LOG "DINGVALID/n";
  }
  print LOG "DING4\n";
}

sub checkOutput {
    my ($accession) = @_;

    my ($validOutput, $noHits);

    if (`grep "no valid contexts" out.txt`) {
      print LOG "\>$accession blast failed on low complexity seq\n";
      $validOutput = 1;
      $noHits = 1;
    } elsif (my $res = `grep -A1 -E "nonnegok|novalidctxok|shortqueryok" out.txt`) {
        print LOG "\>$accession blast failed with: $res \n";
	$validOutput = 1;
	$noHits = 1;
    } elsif (`grep "Sequences producing" out.txt`) {
         $validOutput = 1;
	 $noHits = 0;
	 print LOG "DING5\n";  
    }
    print LOG "DINGCHECK\n";
}
  
sub analyzeBlast{
  my($accession) = @_;
  print LOG "DINGBLAST1\n";
  my $printSum = 0;
  my $printSpan = 0;
  if($outputType =~ /sum/i){
      $printSum = 1;
  }elsif($outputType =~ /span/i){
      $printSpan = 1;
  }elsif($outputType =~ /both/i){
      $printSum = 1;
      $printSpan = 1;
      print LOG "DINGBLAST2\n";
  }

  if($doNotParse eq "true"){ ##in this case must  be saving all blast files...
    my $blastOutFile = "$accession.$fileExtension";
    system("touch '$blastOutFile'");
    system("cat out.txt > '$blastOutFile'");
    system("gzip -f '$blastOutFile'");
    return;
  }
  print LOG "DINGBLAST3\n";
  my $blast = BlastAnal->new($debug);
  my @blastn_out = `cat out.txt`;
  print LOG "DINGBLAST\n";
  $blast->parseBlast($lengthCutoff,$percentCutoff,$pValCutoff,$regex,\@blastn_out,$remMaskedRes,($program =~ /rpsblast/ ? 1 : undef));
  print LOG "PROBNOT\n";
  if ($printSimSeqsFile eq "true"){
    &printSSFile($accession, $blast);
    return;
  }
  print LOG "DING6\n";
  print OUT "\>$accession (".$blast->getSubjectCount()." subjects)\n";
  print STDERR "\>$accession (".$blast->getSubjectCount()." subjects)\n" if $debug;
  foreach my $s ($blast->getSubjects()){
    print OUT $s->getSimilaritySummary(":")."\n" if $printSum;
    print OUT $s->getSimilaritySpans(":")."\n" if $printSpan;
    print LOG "DING7\n";
  }

  if(($saveAllBlastFiles eq "true" && $doNotParse eq "false") || ($saveGoodBlastFiles eq "true" && $blast->getSubjectCount() >= 1)){
    my $blastOutFile = "$accession.$fileExtension";
    print LOG "DINGSAVEGOOD";  
    system("touch $blastOutFile");  
    #system("cat out.txt > $blastOutFile"); 
    #system("gzip -f $blastOutFile");
  }
  }

sub breakSequence{
  my($seq) = @_;
  my $s;
  my $formSeq = "";
  $seq =~ s/\s//g;  ##cleans up newlines and spaces
  for($s=0;$s<length($seq);$s+=80){
    $formSeq .= substr($seq,$s,80) . "\n";
  }
  return $formSeq;
}

sub printSSFile {
  my ($accession, $blast) = @_;

  my @q = split (/\|/, $accession); 
  my $qTaxAbbrev = shift(@q); # taxon is before the first pipe.  beware accession might also have pipes

  foreach my $s ($blast->sortSubjectsByPValue()){

    my $s_accession = $s->getID();
    next if $s_accession eq $accession;

    my ($mant, $exp);
    if ($s->getPValue() =~ /e/) {
      my $pValue = $s->getPValue() =~ /^e/ ?  '1' . $s->getPValue()  : $s->getPValue() ;
      ($mant, $exp) = split(/e/, $pValue);
    } else {
	$mant = int($s->getPValue());
	$exp = 0;
    }

    my @s = split (/\|/, $s->getID());
    my $sTaxAbbrev = shift(@s);

    my $perIdent = sprintf("%.0f", (($s->getTotalIdentities()/$s->getTotalMatchLength())*100));
    my $perMatch = sprintf("%.0f", (int(($s->getLength() < $s->getQueryLength() ? $s->getNonoverlappingSubjectMatchLength() / $s->getLength() : $s->getNonoverlappingQueryMatchLength() / $s->getQueryLength()) * 10000) / 100));

    # accessions must include taxon abbrev prefix
    print OUT "$accession $s_accession $qTaxAbbrev $sTaxAbbrev $mant $exp $perIdent $perMatch\n";
  }
  }
